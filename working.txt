###################################################################
#            PROGRAM LOGIC & WORKING EXPLANATIONS
###################################################################

-------------------------------------------
1. Two-Pass Assembler
-------------------------------------------

### File: assemblerpass1.cpp (Pass 1)

* **Purpose:** To read an assembly language program, build a Symbol Table (SYMTAB), and create an Intermediate Code (IC) file. It does not generate machine code.
* **Key Data Structures:**
    * `OPTAB` (map): An Operation Table that stores mnemonics (like `ADD`) and their machine codes (like `01`).
    * `sym` (ofstream): Output file stream for `symtab.txt`.
    * `inter` (ofstream): Output file stream for `intermediate.txt`.
    * `locctr` (int): The Location Counter, which keeps track of the memory address for each instruction.
* **Step-by-Step Logic:**
    1.  **Initialization:** Opens input (`ass1ip.txt`) and output files. Initializes `locctr = 0`.
    2.  **Read Line-by-Line:** Reads the input file one line at a time.
    3.  **Tokenize:** Splits the line into words (tokens) based on spaces and commas.
    4.  **Handle Directives:**
        * If the first token is `START`, it parses the starting address (e.g., `200`), sets `locctr` to this value, and writes the `START` directive to the intermediate file.
        * If the first token is `END`, it writes `END` to the intermediate file and stops processing.
    5.  **Handle Labels:**
        * It checks if the first token is a known opcode (by looking in `OPTAB`).
        * If it's **NOT** in `OPTAB` (e.g., `LOOP`), it assumes the first token is a **label**.
        * It writes the label (e.g., `LOOP`) and the current `locctr` (e.g., `203`) to `symtab.txt`.
        * It then writes the `locctr`, the opcode (e.g., `SUB`), and the operand (e.g., `D`) to `intermediate.txt`.
    6.  **Handle No Labels:**
        * If the first token **IS** in `OPTAB` (e.g., `MOVER`), it assumes there is no label.
        * It writes the `locctr`, the opcode (e.g., `MOVER`), and the operand (e.g., `B`) to `intermediate.txt`.
    7.  **Increment `locctr`:** After processing any instruction (not a directive), it increments `locctr` by 3 (assuming a fixed instruction length).

### File: assemblerpass2.cpp (Pass 2)

* **Purpose:** To read the Symbol Table and Intermediate Code from Pass 1, and translate the IC into the final machine-readable output.
* **Key Data Structures:**
    * `SYMTAB` (map): A map to store the Symbol Table, loaded from `symtab.txt`. (e.g., `SYMTAB["LOOP"] = "203"`).
    * `OPTAB` (map): An Operation Table, same as in Pass 1.
    * `inter` (ifstream): Input stream for `intermediate.txt`.
    * `sym` (ifstream): Input stream for `symtab.txt`.
    * `out` (ofstream): Output stream for `output.txt`.
* **Step-by-Step Logic:**
    1.  **Load SYMTAB:** Reads `symtab.txt` and populates the `SYMTAB` map.
    2.  **Read Intermediate File:** Reads `intermediate.txt` line by line.
    3.  **Skip Directives:** Ignores lines that contain `START` or `END`.
    4.  **Translate:** For each instruction line (e.g., `203 SUB D`):
        * It takes the opcode (`SUB`) and finds its machine code in `OPTAB` (gets `02`).
        * It takes the operand (`D`) and tries to find it in the `SYMTAB` map.
        * **If found** (e.g., if the operand was `LOOP`), it uses the address from `SYMTAB` (e.g., `203`).
        * **If not found** (as in the case of `D`), it assumes it's a register or literal and uses the operand as-is (`D`).
    5.  **Write Output:** It combines the location counter (`203`), the translated opcode (`02`), and the resolved operand (`D`) and writes them to `output.txt`.

-------------------------------------------
2. Two-Pass Macro-Processor
-------------------------------------------

### File: macropass1.cpp (Pass 1)

* **Purpose:** To read a source file, identify all macro definitions, and create three outputs:
    1.  `mnt.txt` (Macro Name Table): Stores macro names and where their definitions start.
    2.  `mdt.txt` (Macro Definition Table): Stores the actual body of the macro definitions.
    3.  `intermediate.txt`: A copy of the source code with all macro *definitions* removed (but macro *calls* are kept).
* **Key Data Structures:**
    * `mntTable` (vector): Stores `MNT` structs (name, MDT index).
    * `inMacro` (bool): A flag to track if the parser is currently inside a `MACRO...MEND` block.
    * `mdtIndex` (int): A counter for lines in the MDT.
* **Step-by-Step Logic:**
    1.  **Initialization:** Sets `inMacro = false` and `mdtIndex = 1`.
    2.  **Read Line-by-Line:** Reads the input file (`macroip.txt`).
    3.  **Macro Definition Found:** If the line is `MACRO`, it sets `inMacro = true`. It then reads the *next* line (e.g., `INCR &ARG1`), extracts the macro name (`INCR`), and stores it in `mntTable` along with the current `mdtIndex` (`1`).
    4.  **Inside a Macro:** If `inMacro` is `true`:
        * If the line is `MEND`, it writes `MEND` to `mdt.txt`, increments `mdtIndex`, and sets `inMacro = false`.
        * If it's any other line (e.g., `ADD AREG, &ARG1`), it writes the line to `mdt.txt` and increments `mdtIndex`.
    5.  **Outside a Macro:** If `inMacro` is `false`, it means the line is regular code (e.g., `START` or `INCR A`). This line is written directly to `intermediate.txt`.
    6.  **Finalize:** After reading the whole file, it loops through `mntTable` and writes its contents to `mnt.txt`.

### File: macropass2.cpp (Pass 2)

* **Purpose:** To read the `intermediate.txt` (which contains macro *calls*) and expand them using the definitions from `mdt.txt` and `mnt.txt`.
* **Key Data Structures:**
    * `mntTable` (vector): Loaded from `mnt.txt`.
    * `MDT` (vector<string>): The entire Macro Definition Table, loaded from `mdt.txt`.
    * `inter` (ifstream): Input stream for `intermediate.txt`.
    * `out` (ofstream): Output stream for `output.txt`.
* **Step-by-Step Logic:**
    1.  **Load Tables:** Reads `mnt.txt` into `mntTable` and `mdt.txt` into the `MDT` vector.
    2.  **Read Intermediate File:** Reads `intermediate.txt` line by line.
    3.  **Check for Macro Call:** For each line (e.g., `INCR A`), it checks if the first word (`INCR`) exists in the `mntTable`.
    4.  **No Macro Call:** If the word is **not** in `mntTable` (e.g., `START` or `SUB BREG, C`), it copies the line directly to `output.txt`.
    5.  **Macro Call Found:** If the word **is** in `mntTable` (e.g., `INCR A`):
        * It sets `expanded = true`.
        * It finds the macro (`INCR`) in `mntTable` to get its starting MDT index (e.g., `1`).
        * It reads the argument from the call (e.g., `A`).
        * It loops through the `MDT` vector, starting from the correct index (`mdtIndex - 1`).
        * For each line from the MDT (e.g., `ADD AREG, &ARG1`), it performs argument substitution (replaces `&ARG1` with `A`).
        * It writes the *substituted* line (e.g., `ADD AREG, A`) to `output.txt`.
        * This continues until it hits `MEND` in the `MDT`.
    6.  **Repeat:** It continues reading `intermediate.txt` until the end.

---

-------------------------------------------
5. Synchronization (Producer-Consumer)
-------------------------------------------

### File: asss4.cpp

* **Purpose:** To solve the "Producer-Consumer" problem, a classic synchronization problem. It simulates one thread (Producer) creating items and adding them to a shared buffer, and another thread (Consumer) removing items from it, without conflicts.
* **Key Data Structures:**
    * `buffer` (queue): The shared buffer with a fixed `BUFFER_SIZE`.
    * `emptySlots` (sem_t): A semaphore that counts the number of *empty* spots in the buffer. It starts at `BUFFER_SIZE`.
    * `fullSlots` (sem_t): A semaphore that counts the number of *filled* spots in the buffer. It starts at `0`.
    * `mutexLock` (sem_t): A binary semaphore (a mutex) that ensures only one thread can access the `buffer` queue at a time. It starts at `1` (unlocked).
* **Producer Thread Logic (`producer`):**
    1.  `sem_wait(&emptySlots)`: "Waits" for an empty slot. If `emptySlots` is 0, this thread blocks until the consumer makes space.
    2.  `sem_wait(&mutexLock)`: "Waits" to acquire the lock. If the consumer has the lock, it blocks.
    3.  **Critical Section:** `buffer.push(i)` (adds the item) and `cout << "Produced..."`.
    4.  `sem_post(&mutexLock)`: Releases the lock, allowing the consumer (or producer) to enter.
    5.  `sem_post(&fullSlots)`: Signals that a new item has been added, incrementing the `fullSlots` count.
* **Consumer Thread Logic (`consumer`):**
    1.  `sem_wait(&fullSlots)`: "Waits" for a full slot. If `fullSlots` is 0, this thread blocks until the producer adds an item.
    2.  `sem_wait(&mutexLock)`: "Waits" to acquire the lock.
    3.  **Critical Section:** `buffer.pop()` (removes the item) and `cout << "Consumed..."`.
    4.  `sem_post(&mutexLock)`: Releases the lock.
    5.  `sem_post(&emptySlots)`: Signals that an empty slot is now available, incrementing the `emptySlots` count.
* **Main Function:** Initializes the three semaphores, creates the producer and consumer threads, and then waits for them to finish (`pthread_join`).

---

-------------------------------------------
6. CPU Scheduling Algorithms
-------------------------------------------

### File: ass5.cpp

* **Purpose:** To simulate four different CPU scheduling algorithms and calculate the Waiting Time (WT) and Turnaround Time (TAT) for each process.
* **Key Data Structures:**
    * `Process` (struct): Holds process info (`pid`, `at` (arrival), `bt` (burst), `wt`, `tat`, `prio`, `remaining`).
* **Algorithm Logic:**
    1.  **FCFS (First-Come, First-Served):**
        * Sorts all processes by `at` (arrival time).
        * Keeps a `time` counter. It loops through the sorted processes.
        * If `time < process.at`, it sets `time = process.at` (CPU is idle).
        * `wt = time - at`
        * `time = time + bt` (process runs)
        * `tat = wt + bt`
    2.  **SJF (Preemptive) / Shortest-Remaining-Time-First:**
        * This is the most complex. It runs in a loop, simulating one time unit (`t`) at a time.
        * Inside the loop, it searches for the *best* process to run: one that has `at <= t` (has arrived) AND has `remaining > 0` AND has the *minimum* `remaining` time.
        * If no process is ready (`check = false`), it just increments `t` (CPU idle).
        * If a process (`shortest`) is found, it decrements its `remaining` time.
        * When a process's `remaining` hits 0, it's complete. It calculates `finish_time = t + 1`, `tat = finish_time - at`, and `wt = tat - bt`.
        * The loop continues until all processes are complete.
    3.  **Priority (Non-Preemptive):**
        * Sorts processes by `prio` (priority). If priorities are equal, it sorts by `at` as a tie-breaker.
        * After sorting, the logic is **identical to FCFS**. It just runs through the priority-sorted list.
    4.  **Round Robin (Preemptive):**
        * **BUGGY:** This implementation is flawed as it *does not check arrival times*.
        * **Intended Logic:** It loops through all processes repeatedly (`while(true)`).
        * For each process, if `remaining > 0`, it runs it for one `quantum`.
        * If `remaining > quantum`, it subtracts `quantum` from `remaining` and adds `quantum` to `t`.
        * If `remaining <= quantum`, it adds `remaining` to `t`, sets `remaining = 0`, and calculates `wt = t - bt` and `tat = wt + bt`.
        * The outer loop breaks when `done = true` (all processes have `remaining == 0`).

---

-------------------------------------------
7. Memory Placement Strategies
-------------------------------------------

### File: ass6.cpp

* **Purpose:** To simulate four different dynamic memory allocation strategies for placing processes into memory blocks.
* **Key Data Structures:**
    * `blocks` (vector<int>): A list of available memory block sizes.
    * `process` (vector<int>): A list of process sizes that need allocation.
    * `alloc` (vector<int>): Stores which block (`j`) each process (`i`) was allocated to (`-1` = not allocated).
* **Algorithm Logic:** (Note: A copy of `blocks` is passed to each function, so they all start fresh.)
    1.  **First Fit:**
        * For each process `i`:
        * It loops through the blocks `j` from the beginning (`0` to `n-1`).
        * The *first time* it finds a block where `blocks[j] >= process[i]`, it allocates it.
        * It sets `alloc[i] = j`, subtracts the process size (`blocks[j] -= process[i]`), and `break`s the inner loop (to move to the next process).
    2.  **Best Fit:**
        * For each process `i`:
        * It loops through *all* blocks `j`, keeping track of the `best` index found so far.
        * The `best` index is one where `blocks[j] >= process[i]` (it fits) AND `blocks[j]` is *smaller* than the previous `best` block (it's a tighter fit).
        * After checking all blocks, if a `best` index was found, it allocates the process there.
    3.  **Worst Fit:**
        * For each process `i`:
        * It loops through *all* blocks `j`, keeping track of the `worst` index.
        * The `worst` index is one where `blocks[j] >= process[i]` (it fits) AND `blocks[j]` is *larger* than the previous `worst` block (it's the loosest fit).
        * After checking all blocks, if a `worst` index was found, it allocates the process there.
    4.  **Next Fit:**
        * This is like First Fit, but it maintains a `pos` variable (starting at `0`) to remember where it last left off.
        * For each process `i`:
        * It starts searching from `blocks[pos]`.
        * It loops (`count < blocks.size()`) and wraps around the list (`pos = (pos + 1) % blocks.size()`).
        * The *first* block it finds that fits, it allocates, updates `blocks[pos]`, and `break`s. The *next* process will start its search from this `pos`.

---

-------------------------------------------
8. Page Replacement Algorithm
-------------------------------------------

### File: ass7.cpp

* **Purpose:** To simulate the **FIFO (First-In, First-Out)** page replacement algorithm.
* **Key Data Structures:**
    * `pages` (vector<int>): The incoming page reference string.
    * `frameCount` (int): The number of available frames in physical memory.
    * `q` (queue<int>): A queue used to represent the frames. The front of the queue is the *oldest* page, and the back is the *newest*.
* **Algorithm Logic:**
    1.  **Read Input:** Gets the page string and frame count.
    2.  **Iterate Pages:** Loops through each `page` in the `pages` string.
    3.  **Check for Hit (BUGGY):**
        * It creates a copy of the queue (`q2`) and iterates through it to see if the `page` is already present.
        * **THE BUG:** The line `if ( page == f ) found;` is a statement with no effect. It *should* be `if ( page == f ) found = true;`.
        * Because `found` is always `false`, the code *thinks every page is a page fault* (unless the queue isn't full yet).
    4.  **Handle Page Fault (Intended Logic):**
        * If `!found` (which is always true due to the bug):
        * Increment `pageFaults`.
        * `q.push(page)`: Add the new page to the back of the queue.
        * `while(q.size() > frameCount) q.pop()`: If the queue is now too big, remove the *oldest* page from the front.
    5.  **Print State:** After each page access, it prints the current content of the frames (the queue).
    6.  **Final Output:** Prints the `pageFaults` count.